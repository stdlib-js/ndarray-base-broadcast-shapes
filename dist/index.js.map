{
  "version": 3,
  "sources": ["../lib/main.js", "../lib/index.js"],
  "sourcesContent": ["/**\n* @license Apache-2.0\n*\n* Copyright (c) 2021 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MAIN //\n\n/**\n* Broadcasts array shapes to a single shape.\n*\n* ## Notes\n*\n* -   Two respective dimensions in two shape arrays are compatible if\n*\n*     1.  the dimensions are equal.\n*     2.  one dimension is `1`.\n*\n* -   The function returns `null` if provided incompatible shapes (i.e., shapes which cannot be broadcast with one another).\n*\n* @param {Array<NonNegativeIntegerArray>} shapes - array of shape arrays\n* @returns {(NonNegativeIntegerArray|null)} broadcast shape (or `null`)\n*\n* @example\n* var shapes = [\n*     [ 8, 1, 6, 1 ],\n*     [ 7, 1, 5 ]\n* ];\n*\n* var out = broadcastShapes( shapes );\n* // returns [ 8, 7, 6, 5 ]\n*\n* @example\n* var shapes = [\n*     [ 5, 4 ],\n*     [ 1 ]\n* ];\n*\n* var out = broadcastShapes( shapes );\n* // returns [ 5, 4 ]\n*\n* @example\n* var shapes = [\n*     [ 5, 4 ],\n*     [ 4 ]\n* ];\n*\n* var out = broadcastShapes( shapes );\n* // returns [ 5, 4 ]\n*\n* @example\n* var shapes = [\n*     [ 15, 3, 5 ],\n*     [ 15, 1, 5 ]\n* ];\n*\n* var out = broadcastShapes( shapes );\n* // returns [ 15, 3, 5 ]\n*\n* @example\n* var shapes = [\n*     [ 15, 3, 5 ],\n*     [ 3, 5 ]\n* ];\n*\n* var out = broadcastShapes( shapes );\n* // returns [ 15, 3, 5 ]\n*\n* @example\n* var shapes = [\n*     [ 15, 3, 5 ],\n*     [ 3, 1 ]\n* ];\n*\n* var out = broadcastShapes( shapes );\n* // returns [ 15, 3, 5 ]\n*\n* @example\n* var shapes = [\n*     [ 8, 1, 1, 6, 1 ],\n*     [ 1, 7, 1, 5 ],\n*     [ 8, 4, 1, 6, 5 ]\n* ];\n*\n* var out = broadcastShapes( shapes );\n* // returns [ 8, 4, 7, 6, 5 ]\n*\n* @example\n* var shapes = [\n*     [ 8, 1, 1, 6, 1 ],\n*     [ 0 ]\n* ];\n*\n* var out = broadcastShapes( shapes );\n* // returns [ 8, 1, 1, 6, 0 ]\n*\n* @example\n* var shapes = [\n*     [ 8, 1, 1, 6, 1 ],\n*     [ 8, 0, 1, 6, 1 ]\n* ];\n*\n* var out = broadcastShapes( shapes );\n* // returns [ 8, 0, 1, 6, 1 ]\n*\n* @example\n* var shapes = [\n*     [ 8, 8, 1, 6, 1 ],\n*     [ 8, 0, 1, 6, 1 ]\n* ];\n*\n* var out = broadcastShapes( shapes );\n* // returns null\n*\n* @example\n* var shapes = [\n*     [ 8, 0, 1, 6, 1 ],\n*     [ 8, 8, 1, 6, 1 ]\n* ];\n*\n* var out = broadcastShapes( shapes );\n* // returns null\n*\n* @example\n* var shapes = [\n*     []\n* ];\n*\n* var out = broadcastShapes( shapes );\n* // returns []\n*\n* @example\n* var shapes = [\n*     [],\n*     []\n* ];\n*\n* var out = broadcastShapes( shapes );\n* // returns []\n*\n* @example\n* var shapes = [];\n*\n* var out = broadcastShapes( shapes );\n* // returns []\n*\n* @example\n* var shapes = [\n*     [ 3, 2, 1 ],\n*     []\n* ];\n*\n* var out = broadcastShapes( shapes );\n* // returns [ 3, 2, 1 ]\n*\n* @example\n* var shapes = [\n*     [],\n*     [ 3, 2, 1 ]\n* ];\n*\n* var out = broadcastShapes( shapes );\n* // returns [ 3, 2, 1 ]\n*/\nfunction broadcastShapes( shapes ) {\n\tvar ndims;\n\tvar out;\n\tvar dim;\n\tvar sh;\n\tvar n1;\n\tvar n2;\n\tvar d;\n\tvar M;\n\tvar N;\n\tvar i;\n\tvar j;\n\n\tM = shapes.length;\n\tout = [];\n\tif ( M === 0 ) {\n\t\treturn out;\n\t}\n\tsh = shapes[ 0 ];\n\tN = sh.length;\n\n\t// If provided a single input shape array, then the broadcast shape is input shape...\n\tif ( M === 1 ) {\n\t\t// Need to manually copy to output shape, as shapes could be array-like objects...\n\t\tfor ( i = 0; i < N; i++ ) {\n\t\t\tout.push( sh[ i ] );\n\t\t}\n\t\treturn out;\n\t}\n\t// Determine the maximum dimensionality...\n\tndims = [ N ];\n\tfor ( i = 1; i < M; i++ ) {\n\t\tndims.push( shapes[ i ].length );\n\t\tif ( ndims[ i ] > N ) {\n\t\t\tN = ndims[ i ];\n\t\t}\n\t}\n\t// Initialize the output array...\n\tfor ( i = 0; i < N; i++ ) {\n\t\tout.push( 0 );\n\t}\n\t// Compute the broadcast shape...\n\ti = N - 1;\n\twhile ( i >= 0 ) {\n\t\tn1 = ndims[ 0 ] - N + i;\n\t\tif ( n1 >= 0 ) {\n\t\t\tdim = sh[ n1 ];\n\t\t} else {\n\t\t\tdim = 1;\n\t\t}\n\t\tfor ( j = 1; j < M; j++ ) {\n\t\t\tn2 = ndims[ j ] - N + i;\n\t\t\tif ( n2 >= 0 ) {\n\t\t\t\td = shapes[ j ][ n2 ];\n\t\t\t} else {\n\t\t\t\td = 1;\n\t\t\t}\n\t\t\tif ( dim === 1 ) {\n\t\t\t\tdim = d;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif ( d === 1 || dim === d ) {\n\t\t\t\t// When either `d` is `1` or `d` equals the current output shape dimension, the current output shape dimension remains the same...\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t// The current shape cannot be broadcast against one of the other shapes...\n\t\t\treturn null;\n\t\t}\n\t\tout[ i ] = dim;\n\t\ti -= 1;\n\t}\n\treturn out;\n}\n\n\n// EXPORTS //\n\nmodule.exports = broadcastShapes;\n", "/**\n* @license Apache-2.0\n*\n* Copyright (c) 2021 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n/**\n* Broadcast array shapes to a single shape.\n*\n* @module @stdlib/ndarray-base-broadcast-shapes\n*\n* @example\n* var broadcastShapes = require( '@stdlib/ndarray-base-broadcast-shapes' );\n*\n* var shapes = [\n*     [ 8, 1, 6, 1 ],\n*     [ 7, 1, 5 ]\n* ];\n*\n* var out = broadcastShapes( shapes );\n* // returns [ 8, 7, 6, 5 ]\n*/\n\n// MODULES //\n\nvar main = require( './main.js' );\n\n\n// EXPORTS //\n\nmodule.exports = main;\n"],
  "mappings": "uGAAA,IAAAA,EAAAC,EAAA,SAAAC,EAAAC,EAAA,cAkLA,SAASC,EAAiBC,EAAS,CAClC,IAAIC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EAIJ,GAFAH,EAAIR,EAAO,OACXE,EAAM,CAAC,EACFM,IAAM,EACV,OAAON,EAMR,GAJAE,EAAKJ,EAAQ,CAAE,EACfS,EAAIL,EAAG,OAGFI,IAAM,EAAI,CAEd,IAAME,EAAI,EAAGA,EAAID,EAAGC,IACnBR,EAAI,KAAME,EAAIM,CAAE,CAAE,EAEnB,OAAOR,CACR,CAGA,IADAD,EAAQ,CAAEQ,CAAE,EACNC,EAAI,EAAGA,EAAIF,EAAGE,IACnBT,EAAM,KAAMD,EAAQU,CAAE,EAAE,MAAO,EAC1BT,EAAOS,CAAE,EAAID,IACjBA,EAAIR,EAAOS,CAAE,GAIf,IAAMA,EAAI,EAAGA,EAAID,EAAGC,IACnBR,EAAI,KAAM,CAAE,EAIb,IADAQ,EAAID,EAAI,EACAC,GAAK,GAAI,CAOhB,IANAL,EAAKJ,EAAO,CAAE,EAAIQ,EAAIC,EACjBL,GAAM,EACVF,EAAMC,EAAIC,CAAG,EAEbF,EAAM,EAEDQ,EAAI,EAAGA,EAAIH,EAAGG,IAAM,CAOzB,GANAL,EAAKL,EAAOU,CAAE,EAAIF,EAAIC,EACjBJ,GAAM,EACVC,EAAIP,EAAQW,CAAE,EAAGL,CAAG,EAEpBC,EAAI,EAEAJ,IAAQ,EAAI,CAChBA,EAAMI,EACN,QACD,CACA,GAAK,EAAAA,IAAM,GAAKJ,IAAQI,GAKxB,OAAO,IACR,CACAL,EAAKQ,CAAE,EAAIP,EACXO,GAAK,CACN,CACA,OAAOR,CACR,CAKAJ,EAAO,QAAUC,ICxNjB,IAAIa,EAAO,IAKX,OAAO,QAAUA",
  "names": ["require_main", "__commonJSMin", "exports", "module", "broadcastShapes", "shapes", "ndims", "out", "dim", "sh", "n1", "n2", "d", "M", "N", "i", "j", "main"]
}
